# 저장소와 검색

- 데이터베이스가 데이터를 **저장하는 방법**과 데이터를 **요청 했을 때** 다시 찾을 수 있는 방법에 대해 설명
- 특정 작업부하(workload) 유형에서 좋은 성능을 내게끔 저장소 엔진을 조정하려면 저장소 엔진이 내부에서 수행되는 작업에 대해 대략적인 개념 이해 필요
- 관계형 데이터베이스와 NoSQL라 불리는 데이터베이스에 사용되는 저장소 엔진에 대해 설명
- **로그 구조(log-structured) 계열 저장소 엔진**과 B-tree 같은 **페이지 지향(page-oriented) 계열 저장소 엔진** 검토

## 데이터베이스를 강력하게 만드는 데이터 구조

많은 데이터베이스는 내부적으로 **추가 전용(append-only) 데이터 파일인 로그(log)** 를 사용한다. (이 책에서 로그는 조금 더 일반적인 의미로 연속된 추가 전용 레코드다.)
데이터베이스에서 특정 키의 값을 효율적으로 찾기 위해 등장한 데이터 구조가 **색인(index)** 이다.
- 색인을 잘 선택했다면 읽기 질의 속도가 향상된다.
- 모든 색인은 쓰기 속도를 떨어뜨린다.
  - 매번 색인도 갱신해야 하기 때문.
  - 이 때문에 데이터베이스는 보통 자동으로 모든것을 색인하지 않는다.


### 해시 색인

key-value 저장소
- 해시 맵(hash map)으로 구현.

가장 간단한 색인 전략
- 키를 데이터 파일의 바이트 오프셋에 매핑해 인메모리 해시 맵을 유지.

이 방법은 매우 단순해 보이지만 실제로 많이 사용하는 접근법.
- 램(RAM)에 모든 키가 저장된다는 조건을 전제로 고성능 읽기, 쓰기 보장.
- 각 키의 값의 자주 갱신되는 상황에 매우 적합. (ex. key: 동영상 URL, value: 동영상 재생횟수)

파일에 항상 추가만 한다면 디스크 공간 부족 발생. 

*해결 방법?*

특정 크기의 segment로 로그 나누기
- 특정 크기에 도달하면 세그먼트 파일을 닫고 새로운 세그먼트 파일에 쓴다
- 세그먼트 파일에 대해 컴팩션(compaction)을 수행할 수 있다.
  - 컴팩션 : 로그에서 중복된 키를 버리고 각 키의 최신 갱신 값만 유지하는 것을 의미.
- 컴팩션을 하면 세그먼트가 작아지므로, 여러 세그먼트를 병합할 수 있다.
- 세그먼트는 절대 변경 불가 (append-only)
  - 병합할 세그먼트는 새로운 파일로 만든다.
  - 컴팩션을 수행하는 동안 이전 세그먼트 파일을 사용해 읽기와 쓰기요청을 처리한다.
  - 병합 과정이 끝난 이후에는 읽기 요청을 새로 병합한 세그먼트를 사용하게끔 전환한다.
  - 전환 후에는 이전 세그먼트 파일 삭제한다.

조회
- 최신 세그먼트 해시 맵에 찾으려는 키가 있는지 확인한다.
- 최신 세그먼트에 키가 없으면, 다음 세그먼트 해시 맵에서 키를 찾는다.

실제로 구현하려면 세부적으로 많은 사항 고려 필요.
- 파일 형식
- 레코드 삭제
- 고장(crash) 복구
- 부분적으로 레코드 쓰기
- 동시성 제어

