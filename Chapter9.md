# 9. 일관성과 합의

- 8장에서 설명했듯이 분산 시스템에서는 많은 것들이 잘못될 수 있다. (8장에서 설명한 모든 문제가 발생할 수 있다고 가정.) 가장 간단한 방법은 전체 서비스가 실패하도록 두고 사용자에게 오류 메시지를 보여주는 것입니다.
- 이 해결책을 받아들이기 어렵다면 결함을 **견뎌낼(tolerating)** 방법을 찾아야 한다.
- 이번 장에서는 내결함성을 지닌 분산 시스템을 구축하는 데 쓰이는 알고리즘과 프로토콜의 몇 가지 예를 얘기한다.


## 일관성 보장

- 복제 데이터베이스는 대부분 최소한 최종적 일관성을 제공한다.
  - 데이터베이스에 쓰기를 멈추고 불특정 시간 동안 기다리면 결국 모든 읽기 요청이 같은 값을 반환한다.
  - 모든 복제본이 결국 같은 값으로 수렴되기를 기대하므로 최종적 일관성보다 **수렴**이 더 나은 이름일지도 모른다.

- 그러나 이것은 매우 약한 보장이며, 언제 복제본이 수렴될지에 대해서는 아무것도 얘기하지 않는다.

- 약한 보장만 제공하는 데이터베이스를 다룰 때는 그 제한을 계속 알아야 하고 뜻하지 않게 너무 많은 것을 가정하면 안된다.

데이터 시스템이 선택적으로 제공할 수 있는 더욱 강한 일관성 모델을 살펴본다.

- 공통적으로 사용되는 가장 강한 일관성 모델 중 하나인 선형성(linearizability)을 살펴보고 장점과 단점을 검토한다.
- 분산 시스템에서 이벤트 순서화 문제("순서화 보장"), 특히 인과성과 전체 순서화와 관련된 문제를 검토한다.
- "분산 트랜잭션과 합의" 에서 분산 트랜잭션을 원자적으로 커밋하는 방법을 알아본다.

## 선형성

- 기본 아이디어
  - 시스템에 데이터 복사본이 하나만 있고 그 데이터를 대상으로 수행하는 모든 연산은 원자적인 것처럼 보이게 만드는 것

- **원자적 일관성(atomic consitency), 강한 일관성(strong consitency), 즉각 일관성(immediate consitency), 외부 일관성(external consitency)** 이라고도 한다.
- 선형성 시스템에서는 클라이언트가 쓰기를 성공적으로 완료하자마자 그 데이터베이스를 읽는 모든 클라이언트는 방금 쓰여진 값을 볼 수 있어야 한다. 다시 말해 **최신성 보장(recency guarantee)** 이다.

![image 9-1](./image/ch9-1.png)

### 시스템에 선형성을 부여하는 것은 무엇인가?

- 시스템에 데이터 복사본이 하나뿐인 것처럼 보이게 만드는 것이다.
- 분산 시스템 분야에서, 동시에 같은 키 x를 읽고 쓰는 선형성 데이터베이스에서 x는 **레지스터(register)** 라고 불린다.

![image 9-2](./image/ch9-2.png)

- 이 예제에서 레지스터는 두 가지 종류의 연산이 있다.
  - `read(x) => v` 는 클라이언트가 레지스터 x의 값을 읽기를 요청했고 데이터베이스가 값 v를 반환했다는 것을 의미한다.
  - `write(x, v) => r` 은 클라이언트가 레지스터 x의 값을 v로 설정하라고 요청했고 데이터베이스가 응답 r(ok일 수도 error일 수도 있다)을 반환했다는 것을 의미한다.

- 읽기 연산이 처리되는 시점에 쓰기의 영향이 발생했는지 알 수 없으므로 연산은 동시에 실행된다.


![image 9-3](./image/ch9-3.png)
- (그림 9-3) 시스템을 선형적으로 만들려면 또 다른 제약을 추가해야 한다.
- 읽기가 새로운 값을 반환한 적이 있은 후에는 모든 후속 읽기(같은 클라이언트에서 실행되든 다른 클라이언트에서 실행되든)도 반드시 새로운 값을 반환해야 한다.

![image 9-4](./image/ch9-4.png)

- (그림 9-4) 읽기와 쓰기 외에 세 번째 종류의 연산을 추가한다.
  - `cas(x, v_old, v_new) => r` 은 클라이언트가 원자적 `compare-and-set` 연산을 요청했다는 뜻이다.
- 선형성의 요구사항은 연산 표시를 모든 선들이 항상 시간순으로 진행되야 하고(왼손에서 오른쪽으로) 결코 뒤로 가서는 안된다는 것이다.
- 클라이언트 B의 마지막 읽기는 선형적이지 않다.
  - 유효한 순차 순서로 배열되는지 확인함으로써 시스템의 동작이 선형적인지 테스트할 수도 있다.

> 선형성 대 직렬성
> (Linearizability Versus Serializability)

선형성과 직렬성은 혼동하기 쉽다. 그러나 이들 두가지는 매우 다른 보장이며 이들을 구별하는게 중요.

- 직렬성(Serializability)
  - 직렬성은 모든 트랜잭션이 여러 객체(로우, 문서, 레코드)를 읽고 쓸 수 있는 상황에서의 **트랜잭션들**의 격리 속성이다.
  - 트랜잭션들이 **어떤** 순서에 따라 실행되는 것처럼 동작하도록 보장해준다.

- 선형성(Linearizability)
  - 선형성은 레지스터(**개별 객체**)에 실행되는 읽기와 쓰기에 대한 최신성 보장이다.
  - 연산을 트랜잭션으로 묶지 않아서 충돌 구체화 같은 부가적인 수단을 사용하지 않으면 쓰기 스큐 같은 문제를 막지 못한다.

데이터베이스는 직렬성과 선형성을 모두 제공할 수도 있으며 이런 조합은 **엄격한 직렬성(strict serializability)**이나 **강한 단일 복사본 직렬성(strong one-copy serializability)**이라고 한다.
- 2단계 잠금이나 실제적인 직렬 실행을 기반으로 한 직렬성 구현은 보통 선형적이다.
- However, 직렬성 스냅숏 격리(SSI)는 선형적이지 않다.
  - 일관된 스냅숏의 요점은 스냅숏에 스냅숏보다 나중에 실행된 쓰기를 포함하지 않는다는 것이고 따라서 스냅숏에서 읽으면 선형적이지 않다.

### 선형성에 기대기

```선형성이 중요한 요구사항이 되는 영역이 몇가지 있다.```

#### 잠금과 단일 리더 선출
- 단일 리더 복제를 사용하는 시스템은 리더가 여러 개(스플릿 브레인)가 아니라 진짜로 하나만 존재하도록 보장해야 한다.
- 분산 잠금과 리더 선출을 구현하기 위해 아파치 주키퍼(Apache ZooKeeper)나 etcd같은 코디네이션 서비스는 합의 알고리즘을 사용해 선형성 연산을 내결함성이 있는 방식으로 구현한다.
- 오라클 리얼 애플리케이션 클러스터(racle Real Application Clusters, RAC) 같은 분산 데이터베이스에서 훨씬 세분화된 수준으로 사용되기도 한다.
#### 제약 조건과 유일성 보장
- 유일성 제약 조건은 데이터베이스에서 흔하다.(ex. 사용자명이나 이메일 주소, 파알 저장 경로와 파일명)
  - 이러한 조건을 강제하고 싶다면 선형성이 필요합니다.
  - 은행 잔고가 음수가 되지 않게 하거나 동시에 같은 좌석을 예약하지 못하게 보장하고 싶을 때, 모든 노드가 동의하는 하나의 최신값이 있기를 요구한다.
- 실제 애플리케이션에서는 때때로 이런 제약 조건을 느슨하게 다루지만 관계형 데이터베이스에서 전형적으로 볼 수 있는 엄격한 유일성 제약 조건은 선형성이 필요하다.
#### 채널 간 타이밍 의존성
![image 9-5](./image/ch9-5.png)
- 파일 저장 서비스가 선형적이면 이 시스템은 잘 동작하지만. 선형적이지 않으면 경쟁 조건의 위험이 있다.
  - 선형성의 최신성 보장이 없으면 이 두채널 사이에 경쟁 조건이 발생할 수 있다.
- 선형성이 경쟁 조건을 회피하는 유일한 방법은 아니지만 이해하기에 가장 단순한다.

### 선형성 시스템 구현하기

시스템이 내결함성을 지니도록 만드는 가장 흔한 방법은 복제를 사용하는 것이다. 복제 방법을 살펴보면서 선형적으로 만들 수 있는지 비교.
- 단일 리더 복제 : 선형적이 될 가능성 있음
  - 리더나 동기식으로 갱신된 팔로워에서 실행한 읽기는 선형적이 될 가능성이 있다.
  - 읽기에 리더를 사용하려면 누가 리더인지 안다고 가정
- 합의 알고리즘 : 선형적
  - 합의 프로토콜에는 스플릿 브레인과 복제본이 뒤처질 문제를 막을 수단이 포함된다.
  - 이런 세부사항 덕에 합의 알고리즘은 선형성 저장소를 안전하게 구현할 수 있다.

#### 선형성과 정족수

![image 9-6](./image/ch9-6.png)

- 엄격한 정족수를 사용한 읽기 쓰기는 선형적인 것처럼 보인다. 그러나 네트워크 지연의 변동이 심하면 경쟁 조건이 생길 수 있습니다.
- 정족수 조건이 만족됨에도 실행은 선형적이지 않을 수 있습니다.
- 성능이 떨어지는 비용을 지불하고 다이나모 스타일 정족수를 선형적으로 만드는 것도 가능합니다.
  - 읽기를 실행하는 클라이언트는 결과를 애플리케이션에 반환하기 전에 읽기 복구를 동기식으로 수행해야하고 쓰기를 실행하는 클라이언트는 쓰기 요청을 보내기 전에 노드들의 정족수로부터 최신 상태를 읽어야 한다.
  - 이 방법으로는 선형성 compare-and-set 연산은 합의 알고리즘이 필요하므로 구현 불가.
  - 요약하면, 다이나모 스타일 복제를 하는 **리더 없는 시스템은 선형성을 제공하지 않는다** 고 보는게 안전하다.

### 선형성의 비용

## 순서화 보장

### 순서화와 인과성

### 일련번호 순서화

### 전체 순서 브로드캐스트

## 분산 트랜잭션과 합의